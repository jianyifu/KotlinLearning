package kot.fjy.examples.classesobjects

/**
 * Created by fujianyi on 2017/7/17.
 */
/**
 * We frequently create a class to do nothing but hold data.
 * In such a class some standard functionality is often mechanically derivable from the data.
 * In Kotlin, this is called a data class and is marked as data:
 */
open class Human

/**
 * On the JVM, if the generated class needs to have a parameterless constructor,
 * default values for all properties have to be specified (see Constructors).
 */
data class User(val name: String = "none", val age: Int=0):Human()
/**
 * The compiler automatically derives the following members from all properties declared in the primary constructor:
 * 1.equals()/hashCode() pair,
 * 2.toString() of the form "User(name=John, age=42)",
 * 3.componentN() functions corresponding to the properties in their order of declaration,
 * 4.copy() function (see below).
 */
/**
 * To ensure consistency and meaningful behavior of the generated code, data classes have to fulfil the following requirements:
 * The primary constructor needs to have at least one parameter;
 * All primary constructor parameters need to be marked as val or var;
 * Data classes cannot be abstract, open, sealed or inner;
 * (before 1.1) Data classes may only implement interfaces.
 * Since 1.1, data classes may extend other classes (see Sealed classes for examples).
 */

/**
 * Copying
 * It's often the case that we need to copy an object altering some of its properties, but keeping the rest unchanged.
 * This is what copy() function is generated for. For the User class above, its implementation would be as follows:
 */
//fun copy(name: String = this.name, age: Int = this.age) = User(name, age)

/**
 * Destructuring Declarations
 * Component functions generated for data classes enable their use in destructuring declarations:
 * val jane = User("Jane", 35)
 * val (name, age) = jane
 * println("$name, $age years of age") // prints "Jane, 35 years of age"
 */

/**
 * Standard Data Classes
 * The standard library provides Pair and Triple.
 * In most cases, though,named data classes are a better design choice,
 * because they make the code more readable by providing meaningful names for properties.
 */
fun main(args: Array<String>) {
    val jane = User("Jane", 16)
    val jane1 = User("Jane1", 16)
    println(jane)//"User(name=Jane, age=16)" Call the auto generated toString() method.
    println(jane.equals(jane1))
    println(User())
    val jack = User("Jack",13)
    val jackCopy = jack.copy(age = 2)//copy method is auto generated by the compiler.
    println(jackCopy)
    println(jack.hashCode())
    println(jackCopy.hashCode())

    val hill = User("Hill", 35)
    val (name, age) = hill
    println("$name, $age years of age") // prints "Jane, 35 years of age"

    /**
     * Pair and Triple examples
     */
    val (a, b) = Pair(1, "x")
    println(a) // 1
    println(b) // x

    val myTriple = Triple(2, "x", listOf(null))
    println(myTriple.first) // 2
    println(myTriple.second) // x
    println(myTriple.third) // [null]
    println(myTriple.toList())
    println(myTriple)
}